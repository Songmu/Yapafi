## 正しいURIについて(★書きかけ)

思想的な部分に触れつつ、現状の対応案を示します。

**「URLを見るとどういう情報が得られるか(どういう操作をしているか)をユーザーに示すことが出来る」**

というところが理想です。

### URLはリソースにマッピングされる

**URLはファイルにマッピングされている訳ではなく「リソース」にマッピングされている**と考えます。昔「ファイル=リソース」だったというだけの話で、RDBにデータを持っている場合などはその限りではありません。

例えば、以下のようなURLを考えてみましょう。

<pre><samp>http://www.example.com/user/15.html</samp></pre>

これは、データベース上のuserテーブルのid15番の人の情報をポイントしていると考えられます。  
(もちろんこれはRDBに寄った考え方で、リソースがRDBである必要はありません。)

末尾の.htmlはメタ情報を示します。この場合レスポンスのデータ形式を示しています。html形式のデータが返ってくることが示されています。

これは**「htmlファイルがサーバーに存在することを示す訳ではない」**点に気をつけてください。  
(このページも末尾が.htmlになっていますが中身はPHPです。)

この原則を適用すると、URLに応じてデータ形式を動的に出し分けると言ったこともイメージが湧くかと思います。

<pre><samp>http://www.example.com/user/15.json
http://www.example.com/user/15.xml
http://www.example.com/user/15.ja.html
http://www.example.com/user/15</samp></pre>

最後のURLには.jaと書かれています。メタ情報はファイル形式であるとは限りません(この場合は言語情報)。また、アプリケーション寄りのURLの場合、メタ情報はつけないことも多いです(最後の例)。

.php .cgi .do等開発言語・フレームワークに依存した拡張子は本質的には好ましくありません。これだと開発言語が変わった際などにURLを変更することにもなってしまいます。  
(例えば、Twitterは初期はRuby on Railsで書かれていましたが、今はScalaです。それでもURLは変更されていません。)

このように、URLとリソースの結びつきを強く意識したアーキテクチャは**REST**と呼ばれ、近年Webを構築する上で重要な概念となってきています。


### クールなURL

さて、先ほどのアドレスの意味するところは、以下のURLのようにクエリー文字列でも同じように表現することが可能です。

<pre><samp>http://www.example.com/?page=user&id=15</samp></pre>

しかし、

<pre><samp>http://www.example.com/user/15</samp></pre>

の方が分かりやすいと思う人の方が多いでしょう。

実際多くのレガシーWebフレームワークではクエリー文字列によってページを出し分けている物が少なくありません。ただそれは古いやり方です。

ユーザーにフォームを入力させるならともかく(Googleの検索結果のように)、クエリーで見た目を大きく分けるのはあまりクールではありません。クエリー文字列は付随的な情報で、ユーザーが自由にいじれるもの／任意に入力したものというイメージが強いからです。また、アプリケーション的にもどれがユーザーが入力した情報なのか、判定が煩雑になってしまいます。

また、クエリー付き文字列でページを出し分けていたとしても、検索エンジンに別ページとして認識されにくいという問題があります。最近はそうでもないようですが。

\*ちなみに本来、クールなURLとは見た目にカッコよいということではなく、永続的かつ意味付けがしっかりしていると言うことです。

<aside>余談ですが、逆に別のクエリー引数(モバイルのセッションIDなど)をつけていても同じページだと検索エンジンにみなしてもらいたい場合はcanonical urlの設定をするとよいでしょう。
<pre><code>&lt;link rel=&quot;canonical&quot; href=&quot;http://www.example.com/&quot;&gt;</code></pre>
上記のようにHTML内に記述しておくと、以下のアドレスは <samp>http://www.example.com/</samp> と同一だとみなされます。
<pre><samp>http://www.example.com/?sessid=hogehogefugafuga
http://www.example.com/?sessid=12345678
</samp></pre>
これは、http://example.com/とhttp://www.example.com/を同じURLだとみなしてもらいたい場合等にも有効です。(ただ、この場合は301リダイレクトを行うほうが適切です)
</aside>

### HTTPメソッドの違い

現状のブラウザの対応状況から鑑みて、主にGETメソッドとPOSTメソッドを使うことになりますが、以下のように切り分けられます。

- GETメソッドはデータの閲覧に使う
- POSTメソッドはデータの更新に使う

GETメソッドは「冪等性」が保証されていると言われます。**つまり何度GETリクエストを送ったとしても同じ結果が返る。**ということです。他の要因がリソースを更新した場合はこの限りではありませんが、GETメソッド自体がリソースを更新することはしないということです。

「FormはPOST」と考えがちですが、これも間違いです。例えばGoogleの検索結果はGETで入力を引き渡しています。リソースの更新を行なっているのはクローラであり、リクエスト自体はリソースの更新を行わないからです。

例えば、先ほどURLの例だと以下のような考え方になります。

GET の場合
: userテーブルのid15番の人の情報の「閲覧」を行う(SELECT文)

POSTの場合
: userテーブルのid15番の人の情報の「更新」を行う(INSERT,UPDATE,DELETE文)

また、POSTリクエストではデータの更新*のみ*を行うべきで、同時にビューも返すと言った実装はするべきではありません。

これは思想的な点だけではなく、ロジックの独立性を保つ上でも、ブラウザへの対応の観点からも重要です。  
(POSTでビューを返してしまうとブラウザバックを行った際に「情報の再送信を行いますか？」などと文言が表示されてしまい、ユーザーを混乱させることになるます。)

ではどうするかと言うとPOSTリクエストに対しては、次のURLを示した303リダイレクトを返すのが正しい処理になります。  
(これは現状のブラウザで操作されることを前提とした場合の話です。)

<aside><p>HTTPメソッドにはPUT, DELETEもあり、この辺りが使えるとまた明確に処理を分けることができるようになり、本来のWebのあり方に近づきます。ただし、Webサーバー、ブラウザの対応を考えると本格的に使えるのはまだまだ先になるでしょう。</p>
<p>YapafiはオーバーロードPOSTという擬似REST方式に対応しています。具体的にはPOSTリクエスト時にクエリー文字列のキーに"_method"が存在する場合、その値をHTTPメソッドとしてエミュレートする機能です。これはRuby on Railsで発案され、その後近年のWebアプリケーションフレームワークの多くに実装されています。</p></aside>


### URLの動詞化

URLはリソースを指し示すものなので本来名詞です(book.html, calendar.ja等)。しかし現在、Webは単なるリソースの枠組みを越え、アプリケーションとしての用途にも使われています。

そういった場合、URLに動詞を使うことが増えてきました(edit等)。本来のあり方とは異なりますが、そういった使い方も認められてきています。TwitterのURL設計が良い例です。

<aside>HTML5の仕様が議論され、普及し始めています。その大きな目的の一つに、Webを単なるリソースの集合ではなくアプリケーションとしての枠組みを確立し、これまでのWebとの統合を図ることがあります。また、HTML5はHTMLの新たな規格というよりも、CSS3、次世代JavaScriptも包含したWebの新たなあり方を示した概念だと考えるとよいでしょう。実際HTML5という規格は無くなりHTMLとしか言われなくなりました。</aside>


### URL設計

Webアプリケーションを作る上で、データベース設計と同じくらいURL設計は重要です。

